/*
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.21.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = Camunda.OpenApi.Client.Client.FileParameter;
using OpenAPIDateConverter = Camunda.OpenApi.Client.Client.OpenAPIDateConverter;

namespace Camunda.OpenApi.Client.Model
{
    /// <summary>
    /// A Historic Task instance query which defines a list of Historic Task instances
    /// </summary>
    [DataContract(Name = "HistoricTaskInstanceQueryDto")]
    public partial class HistoricTaskInstanceQueryDto : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="HistoricTaskInstanceQueryDto" /> class.
        /// </summary>
        /// <param name="taskId">Filter by task id..</param>
        /// <param name="taskParentTaskId">Filter by parent task id..</param>
        /// <param name="processInstanceId">Filter by process instance id..</param>
        /// <param name="processInstanceBusinessKey">Filter by process instance business key..</param>
        /// <param name="processInstanceBusinessKeyIn">Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list..</param>
        /// <param name="processInstanceBusinessKeyLike">Filter by  process instance business key that has the parameter value as a substring..</param>
        /// <param name="executionId">Filter by the id of the execution that executed the task..</param>
        /// <param name="processDefinitionId">Filter by process definition id..</param>
        /// <param name="processDefinitionKey">Restrict to tasks that belong to a process definition with the given key..</param>
        /// <param name="processDefinitionName">Restrict to tasks that belong to a process definition with the given name..</param>
        /// <param name="caseInstanceId">Filter by case instance id..</param>
        /// <param name="caseExecutionId">Filter by the id of the case execution that executed the task..</param>
        /// <param name="caseDefinitionId">Filter by case definition id..</param>
        /// <param name="caseDefinitionKey">Restrict to tasks that belong to a case definition with the given key..</param>
        /// <param name="caseDefinitionName">Restrict to tasks that belong to a case definition with the given name..</param>
        /// <param name="activityInstanceIdIn">Only include tasks which belong to one of the passed  activity instance ids..</param>
        /// <param name="taskName">Restrict to tasks that have the given name..</param>
        /// <param name="taskNameLike">Restrict to tasks that have a name with the given parameter value as substring..</param>
        /// <param name="taskDescription">Restrict to tasks that have the given description..</param>
        /// <param name="taskDescriptionLike">Restrict to tasks that have a description that has the parameter value as a substring..</param>
        /// <param name="taskDefinitionKey">Restrict to tasks that have the given key..</param>
        /// <param name="taskDefinitionKeyIn">Restrict to tasks that have one of the passed  task definition keys..</param>
        /// <param name="taskDeleteReason">Restrict to tasks that have the given delete reason..</param>
        /// <param name="taskDeleteReasonLike">Restrict to tasks that have a delete reason that has the parameter value as a substring..</param>
        /// <param name="taskAssignee">Restrict to tasks that the given user is assigned to..</param>
        /// <param name="taskAssigneeLike">Restrict to tasks that are assigned to users with the parameter value as a substring..</param>
        /// <param name="taskOwner">Restrict to tasks that the given user owns..</param>
        /// <param name="taskOwnerLike">Restrict to tasks that are owned by users with the parameter value as a substring..</param>
        /// <param name="taskPriority">Restrict to tasks that have the given priority..</param>
        /// <param name="assigned">If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned..</param>
        /// <param name="unassigned">If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned..</param>
        /// <param name="finished">Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="unfinished">Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="processFinished">Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="processUnfinished">Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="taskDueDate">Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="taskDueDateBefore">Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="taskDueDateAfter">Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="withoutTaskDueDate">Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="taskFollowUpDate">Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="taskFollowUpDateBefore">Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="taskFollowUpDateAfter">Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="startedBefore">Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="startedAfter">Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="finishedBefore">Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="finishedAfter">Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;..</param>
        /// <param name="tenantIdIn">Filter by a  list of tenant ids. A task instance must have one of the given tenant ids..</param>
        /// <param name="withoutTenantId">Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="taskVariables">Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters..</param>
        /// <param name="processVariables">Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters..</param>
        /// <param name="variableNamesIgnoreCase">Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal..</param>
        /// <param name="variableValuesIgnoreCase">Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal..</param>
        /// <param name="taskInvolvedUser">Restrict to tasks with a historic identity link to the given user..</param>
        /// <param name="taskInvolvedGroup">Restrict to tasks with a historic identity link to the given group..</param>
        /// <param name="taskHadCandidateUser">Restrict to tasks with a historic identity link to the given candidate user..</param>
        /// <param name="taskHadCandidateGroup">Restrict to tasks with a historic identity link to the given candidate group..</param>
        /// <param name="withCandidateGroups">Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="withoutCandidateGroups">Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior..</param>
        /// <param name="orQueries">A JSON array of nested historic task instance queries with OR semantics.  A task instance matches a nested query if it fulfills at least one of the query&#39;s predicates.  With multiple nested queries, a task instance must fulfill at least one predicate of each query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task instance query properties can be used except for: &#x60;sorting&#x60;, &#x60;withCandidateGroups&#x60;, &#x60; withoutCandidateGroups&#x60;.  See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries..</param>
        /// <param name="sorting">An array of criteria to sort the result by. Each element of the array is                     an object that specifies one ordering. The position in the array                     identifies the rank of an ordering, i.e., whether it is primary, secondary,                     etc. Sorting has no effect for &#x60;count&#x60; endpoints.</param>
        public HistoricTaskInstanceQueryDto(string taskId = default(string), string taskParentTaskId = default(string), string processInstanceId = default(string), string processInstanceBusinessKey = default(string), List<string> processInstanceBusinessKeyIn = default(List<string>), string processInstanceBusinessKeyLike = default(string), string executionId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionName = default(string), string caseInstanceId = default(string), string caseExecutionId = default(string), string caseDefinitionId = default(string), string caseDefinitionKey = default(string), string caseDefinitionName = default(string), List<string> activityInstanceIdIn = default(List<string>), string taskName = default(string), string taskNameLike = default(string), string taskDescription = default(string), string taskDescriptionLike = default(string), string taskDefinitionKey = default(string), List<string> taskDefinitionKeyIn = default(List<string>), string taskDeleteReason = default(string), string taskDeleteReasonLike = default(string), string taskAssignee = default(string), string taskAssigneeLike = default(string), string taskOwner = default(string), string taskOwnerLike = default(string), int? taskPriority = default(int?), bool? assigned = default(bool?), bool? unassigned = default(bool?), bool? finished = default(bool?), bool? unfinished = default(bool?), bool? processFinished = default(bool?), bool? processUnfinished = default(bool?), DateTime? taskDueDate = default(DateTime?), DateTime? taskDueDateBefore = default(DateTime?), DateTime? taskDueDateAfter = default(DateTime?), bool? withoutTaskDueDate = default(bool?), DateTime? taskFollowUpDate = default(DateTime?), DateTime? taskFollowUpDateBefore = default(DateTime?), DateTime? taskFollowUpDateAfter = default(DateTime?), DateTime? startedBefore = default(DateTime?), DateTime? startedAfter = default(DateTime?), DateTime? finishedBefore = default(DateTime?), DateTime? finishedAfter = default(DateTime?), List<string> tenantIdIn = default(List<string>), bool? withoutTenantId = default(bool?), List<VariableQueryParameterDto> taskVariables = default(List<VariableQueryParameterDto>), List<VariableQueryParameterDto> processVariables = default(List<VariableQueryParameterDto>), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), string taskInvolvedUser = default(string), string taskInvolvedGroup = default(string), string taskHadCandidateUser = default(string), string taskHadCandidateGroup = default(string), bool? withCandidateGroups = default(bool?), bool? withoutCandidateGroups = default(bool?), List<HistoricTaskInstanceQueryDto> orQueries = default(List<HistoricTaskInstanceQueryDto>), List<HistoricTaskInstanceQueryDtoSortingInner> sorting = default(List<HistoricTaskInstanceQueryDtoSortingInner>))
        {
            this.TaskId = taskId;
            this.TaskParentTaskId = taskParentTaskId;
            this.ProcessInstanceId = processInstanceId;
            this.ProcessInstanceBusinessKey = processInstanceBusinessKey;
            this.ProcessInstanceBusinessKeyIn = processInstanceBusinessKeyIn;
            this.ProcessInstanceBusinessKeyLike = processInstanceBusinessKeyLike;
            this.ExecutionId = executionId;
            this.ProcessDefinitionId = processDefinitionId;
            this.ProcessDefinitionKey = processDefinitionKey;
            this.ProcessDefinitionName = processDefinitionName;
            this.CaseInstanceId = caseInstanceId;
            this.CaseExecutionId = caseExecutionId;
            this.CaseDefinitionId = caseDefinitionId;
            this.CaseDefinitionKey = caseDefinitionKey;
            this.CaseDefinitionName = caseDefinitionName;
            this.ActivityInstanceIdIn = activityInstanceIdIn;
            this.TaskName = taskName;
            this.TaskNameLike = taskNameLike;
            this.TaskDescription = taskDescription;
            this.TaskDescriptionLike = taskDescriptionLike;
            this.TaskDefinitionKey = taskDefinitionKey;
            this.TaskDefinitionKeyIn = taskDefinitionKeyIn;
            this.TaskDeleteReason = taskDeleteReason;
            this.TaskDeleteReasonLike = taskDeleteReasonLike;
            this.TaskAssignee = taskAssignee;
            this.TaskAssigneeLike = taskAssigneeLike;
            this.TaskOwner = taskOwner;
            this.TaskOwnerLike = taskOwnerLike;
            this.TaskPriority = taskPriority;
            this.Assigned = assigned;
            this.Unassigned = unassigned;
            this.Finished = finished;
            this.Unfinished = unfinished;
            this.ProcessFinished = processFinished;
            this.ProcessUnfinished = processUnfinished;
            this.TaskDueDate = taskDueDate;
            this.TaskDueDateBefore = taskDueDateBefore;
            this.TaskDueDateAfter = taskDueDateAfter;
            this.WithoutTaskDueDate = withoutTaskDueDate;
            this.TaskFollowUpDate = taskFollowUpDate;
            this.TaskFollowUpDateBefore = taskFollowUpDateBefore;
            this.TaskFollowUpDateAfter = taskFollowUpDateAfter;
            this.StartedBefore = startedBefore;
            this.StartedAfter = startedAfter;
            this.FinishedBefore = finishedBefore;
            this.FinishedAfter = finishedAfter;
            this.TenantIdIn = tenantIdIn;
            this.WithoutTenantId = withoutTenantId;
            this.TaskVariables = taskVariables;
            this.ProcessVariables = processVariables;
            this.VariableNamesIgnoreCase = variableNamesIgnoreCase;
            this.VariableValuesIgnoreCase = variableValuesIgnoreCase;
            this.TaskInvolvedUser = taskInvolvedUser;
            this.TaskInvolvedGroup = taskInvolvedGroup;
            this.TaskHadCandidateUser = taskHadCandidateUser;
            this.TaskHadCandidateGroup = taskHadCandidateGroup;
            this.WithCandidateGroups = withCandidateGroups;
            this.WithoutCandidateGroups = withoutCandidateGroups;
            this.OrQueries = orQueries;
            this.Sorting = sorting;
        }

        /// <summary>
        /// Filter by task id.
        /// </summary>
        /// <value>Filter by task id.</value>
        [DataMember(Name = "taskId", EmitDefaultValue = true)]
        public string TaskId { get; set; }

        /// <summary>
        /// Filter by parent task id.
        /// </summary>
        /// <value>Filter by parent task id.</value>
        [DataMember(Name = "taskParentTaskId", EmitDefaultValue = true)]
        public string TaskParentTaskId { get; set; }

        /// <summary>
        /// Filter by process instance id.
        /// </summary>
        /// <value>Filter by process instance id.</value>
        [DataMember(Name = "processInstanceId", EmitDefaultValue = true)]
        public string ProcessInstanceId { get; set; }

        /// <summary>
        /// Filter by process instance business key.
        /// </summary>
        /// <value>Filter by process instance business key.</value>
        [DataMember(Name = "processInstanceBusinessKey", EmitDefaultValue = true)]
        public string ProcessInstanceBusinessKey { get; set; }

        /// <summary>
        /// Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.
        /// </summary>
        /// <value>Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list.</value>
        [DataMember(Name = "processInstanceBusinessKeyIn", EmitDefaultValue = true)]
        public List<string> ProcessInstanceBusinessKeyIn { get; set; }

        /// <summary>
        /// Filter by  process instance business key that has the parameter value as a substring.
        /// </summary>
        /// <value>Filter by  process instance business key that has the parameter value as a substring.</value>
        [DataMember(Name = "processInstanceBusinessKeyLike", EmitDefaultValue = true)]
        public string ProcessInstanceBusinessKeyLike { get; set; }

        /// <summary>
        /// Filter by the id of the execution that executed the task.
        /// </summary>
        /// <value>Filter by the id of the execution that executed the task.</value>
        [DataMember(Name = "executionId", EmitDefaultValue = true)]
        public string ExecutionId { get; set; }

        /// <summary>
        /// Filter by process definition id.
        /// </summary>
        /// <value>Filter by process definition id.</value>
        [DataMember(Name = "processDefinitionId", EmitDefaultValue = true)]
        public string ProcessDefinitionId { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a process definition with the given key.
        /// </summary>
        /// <value>Restrict to tasks that belong to a process definition with the given key.</value>
        [DataMember(Name = "processDefinitionKey", EmitDefaultValue = true)]
        public string ProcessDefinitionKey { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a process definition with the given name.
        /// </summary>
        /// <value>Restrict to tasks that belong to a process definition with the given name.</value>
        [DataMember(Name = "processDefinitionName", EmitDefaultValue = true)]
        public string ProcessDefinitionName { get; set; }

        /// <summary>
        /// Filter by case instance id.
        /// </summary>
        /// <value>Filter by case instance id.</value>
        [DataMember(Name = "caseInstanceId", EmitDefaultValue = true)]
        public string CaseInstanceId { get; set; }

        /// <summary>
        /// Filter by the id of the case execution that executed the task.
        /// </summary>
        /// <value>Filter by the id of the case execution that executed the task.</value>
        [DataMember(Name = "caseExecutionId", EmitDefaultValue = true)]
        public string CaseExecutionId { get; set; }

        /// <summary>
        /// Filter by case definition id.
        /// </summary>
        /// <value>Filter by case definition id.</value>
        [DataMember(Name = "caseDefinitionId", EmitDefaultValue = true)]
        public string CaseDefinitionId { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a case definition with the given key.
        /// </summary>
        /// <value>Restrict to tasks that belong to a case definition with the given key.</value>
        [DataMember(Name = "caseDefinitionKey", EmitDefaultValue = true)]
        public string CaseDefinitionKey { get; set; }

        /// <summary>
        /// Restrict to tasks that belong to a case definition with the given name.
        /// </summary>
        /// <value>Restrict to tasks that belong to a case definition with the given name.</value>
        [DataMember(Name = "caseDefinitionName", EmitDefaultValue = true)]
        public string CaseDefinitionName { get; set; }

        /// <summary>
        /// Only include tasks which belong to one of the passed  activity instance ids.
        /// </summary>
        /// <value>Only include tasks which belong to one of the passed  activity instance ids.</value>
        [DataMember(Name = "activityInstanceIdIn", EmitDefaultValue = true)]
        public List<string> ActivityInstanceIdIn { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given name.
        /// </summary>
        /// <value>Restrict to tasks that have the given name.</value>
        [DataMember(Name = "taskName", EmitDefaultValue = true)]
        public string TaskName { get; set; }

        /// <summary>
        /// Restrict to tasks that have a name with the given parameter value as substring.
        /// </summary>
        /// <value>Restrict to tasks that have a name with the given parameter value as substring.</value>
        [DataMember(Name = "taskNameLike", EmitDefaultValue = true)]
        public string TaskNameLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given description.
        /// </summary>
        /// <value>Restrict to tasks that have the given description.</value>
        [DataMember(Name = "taskDescription", EmitDefaultValue = true)]
        public string TaskDescription { get; set; }

        /// <summary>
        /// Restrict to tasks that have a description that has the parameter value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that have a description that has the parameter value as a substring.</value>
        [DataMember(Name = "taskDescriptionLike", EmitDefaultValue = true)]
        public string TaskDescriptionLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given key.
        /// </summary>
        /// <value>Restrict to tasks that have the given key.</value>
        [DataMember(Name = "taskDefinitionKey", EmitDefaultValue = true)]
        public string TaskDefinitionKey { get; set; }

        /// <summary>
        /// Restrict to tasks that have one of the passed  task definition keys.
        /// </summary>
        /// <value>Restrict to tasks that have one of the passed  task definition keys.</value>
        [DataMember(Name = "taskDefinitionKeyIn", EmitDefaultValue = true)]
        public List<string> TaskDefinitionKeyIn { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given delete reason.
        /// </summary>
        /// <value>Restrict to tasks that have the given delete reason.</value>
        [DataMember(Name = "taskDeleteReason", EmitDefaultValue = true)]
        public string TaskDeleteReason { get; set; }

        /// <summary>
        /// Restrict to tasks that have a delete reason that has the parameter value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that have a delete reason that has the parameter value as a substring.</value>
        [DataMember(Name = "taskDeleteReasonLike", EmitDefaultValue = true)]
        public string TaskDeleteReasonLike { get; set; }

        /// <summary>
        /// Restrict to tasks that the given user is assigned to.
        /// </summary>
        /// <value>Restrict to tasks that the given user is assigned to.</value>
        [DataMember(Name = "taskAssignee", EmitDefaultValue = true)]
        public string TaskAssignee { get; set; }

        /// <summary>
        /// Restrict to tasks that are assigned to users with the parameter value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that are assigned to users with the parameter value as a substring.</value>
        [DataMember(Name = "taskAssigneeLike", EmitDefaultValue = true)]
        public string TaskAssigneeLike { get; set; }

        /// <summary>
        /// Restrict to tasks that the given user owns.
        /// </summary>
        /// <value>Restrict to tasks that the given user owns.</value>
        [DataMember(Name = "taskOwner", EmitDefaultValue = true)]
        public string TaskOwner { get; set; }

        /// <summary>
        /// Restrict to tasks that are owned by users with the parameter value as a substring.
        /// </summary>
        /// <value>Restrict to tasks that are owned by users with the parameter value as a substring.</value>
        [DataMember(Name = "taskOwnerLike", EmitDefaultValue = true)]
        public string TaskOwnerLike { get; set; }

        /// <summary>
        /// Restrict to tasks that have the given priority.
        /// </summary>
        /// <value>Restrict to tasks that have the given priority.</value>
        [DataMember(Name = "taskPriority", EmitDefaultValue = true)]
        public int? TaskPriority { get; set; }

        /// <summary>
        /// If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
        /// </summary>
        /// <value>If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.</value>
        [DataMember(Name = "assigned", EmitDefaultValue = true)]
        public bool? Assigned { get; set; }

        /// <summary>
        /// If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
        /// </summary>
        /// <value>If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.</value>
        [DataMember(Name = "unassigned", EmitDefaultValue = true)]
        public bool? Unassigned { get; set; }

        /// <summary>
        /// Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "finished", EmitDefaultValue = true)]
        public bool? Finished { get; set; }

        /// <summary>
        /// Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "unfinished", EmitDefaultValue = true)]
        public bool? Unfinished { get; set; }

        /// <summary>
        /// Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "processFinished", EmitDefaultValue = true)]
        public bool? ProcessFinished { get; set; }

        /// <summary>
        /// Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "processUnfinished", EmitDefaultValue = true)]
        public bool? ProcessUnfinished { get; set; }

        /// <summary>
        /// Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "taskDueDate", EmitDefaultValue = true)]
        public DateTime? TaskDueDate { get; set; }

        /// <summary>
        /// Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "taskDueDateBefore", EmitDefaultValue = true)]
        public DateTime? TaskDueDateBefore { get; set; }

        /// <summary>
        /// Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "taskDueDateAfter", EmitDefaultValue = true)]
        public DateTime? TaskDueDateAfter { get; set; }

        /// <summary>
        /// Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutTaskDueDate", EmitDefaultValue = true)]
        public bool? WithoutTaskDueDate { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "taskFollowUpDate", EmitDefaultValue = true)]
        public DateTime? TaskFollowUpDate { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "taskFollowUpDateBefore", EmitDefaultValue = true)]
        public DateTime? TaskFollowUpDateBefore { get; set; }

        /// <summary>
        /// Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "taskFollowUpDateAfter", EmitDefaultValue = true)]
        public DateTime? TaskFollowUpDateAfter { get; set; }

        /// <summary>
        /// Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "startedBefore", EmitDefaultValue = true)]
        public DateTime? StartedBefore { get; set; }

        /// <summary>
        /// Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "startedAfter", EmitDefaultValue = true)]
        public DateTime? StartedAfter { get; set; }

        /// <summary>
        /// Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "finishedBefore", EmitDefaultValue = true)]
        public DateTime? FinishedBefore { get; set; }

        /// <summary>
        /// Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
        /// </summary>
        /// <value>Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.</value>
        [DataMember(Name = "finishedAfter", EmitDefaultValue = true)]
        public DateTime? FinishedAfter { get; set; }

        /// <summary>
        /// Filter by a  list of tenant ids. A task instance must have one of the given tenant ids.
        /// </summary>
        /// <value>Filter by a  list of tenant ids. A task instance must have one of the given tenant ids.</value>
        [DataMember(Name = "tenantIdIn", EmitDefaultValue = true)]
        public List<string> TenantIdIn { get; set; }

        /// <summary>
        /// Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutTenantId", EmitDefaultValue = true)]
        public bool? WithoutTenantId { get; set; }

        /// <summary>
        /// Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
        /// </summary>
        /// <value>Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.</value>
        [DataMember(Name = "taskVariables", EmitDefaultValue = true)]
        public List<VariableQueryParameterDto> TaskVariables { get; set; }

        /// <summary>
        /// Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
        /// </summary>
        /// <value>Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.</value>
        [DataMember(Name = "processVariables", EmitDefaultValue = true)]
        public List<VariableQueryParameterDto> ProcessVariables { get; set; }

        /// <summary>
        /// Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.
        /// </summary>
        /// <value>Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal.</value>
        [DataMember(Name = "variableNamesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableNamesIgnoreCase { get; set; }

        /// <summary>
        /// Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.
        /// </summary>
        /// <value>Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal.</value>
        [DataMember(Name = "variableValuesIgnoreCase", EmitDefaultValue = true)]
        public bool? VariableValuesIgnoreCase { get; set; }

        /// <summary>
        /// Restrict to tasks with a historic identity link to the given user.
        /// </summary>
        /// <value>Restrict to tasks with a historic identity link to the given user.</value>
        [DataMember(Name = "taskInvolvedUser", EmitDefaultValue = true)]
        public string TaskInvolvedUser { get; set; }

        /// <summary>
        /// Restrict to tasks with a historic identity link to the given group.
        /// </summary>
        /// <value>Restrict to tasks with a historic identity link to the given group.</value>
        [DataMember(Name = "taskInvolvedGroup", EmitDefaultValue = true)]
        public string TaskInvolvedGroup { get; set; }

        /// <summary>
        /// Restrict to tasks with a historic identity link to the given candidate user.
        /// </summary>
        /// <value>Restrict to tasks with a historic identity link to the given candidate user.</value>
        [DataMember(Name = "taskHadCandidateUser", EmitDefaultValue = true)]
        public string TaskHadCandidateUser { get; set; }

        /// <summary>
        /// Restrict to tasks with a historic identity link to the given candidate group.
        /// </summary>
        /// <value>Restrict to tasks with a historic identity link to the given candidate group.</value>
        [DataMember(Name = "taskHadCandidateGroup", EmitDefaultValue = true)]
        public string TaskHadCandidateGroup { get; set; }

        /// <summary>
        /// Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withCandidateGroups", EmitDefaultValue = true)]
        public bool? WithCandidateGroups { get; set; }

        /// <summary>
        /// Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
        /// </summary>
        /// <value>Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.</value>
        [DataMember(Name = "withoutCandidateGroups", EmitDefaultValue = true)]
        public bool? WithoutCandidateGroups { get; set; }

        /// <summary>
        /// A JSON array of nested historic task instance queries with OR semantics.  A task instance matches a nested query if it fulfills at least one of the query&#39;s predicates.  With multiple nested queries, a task instance must fulfill at least one predicate of each query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task instance query properties can be used except for: &#x60;sorting&#x60;, &#x60;withCandidateGroups&#x60;, &#x60; withoutCandidateGroups&#x60;.  See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
        /// </summary>
        /// <value>A JSON array of nested historic task instance queries with OR semantics.  A task instance matches a nested query if it fulfills at least one of the query&#39;s predicates.  With multiple nested queries, a task instance must fulfill at least one predicate of each query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task instance query properties can be used except for: &#x60;sorting&#x60;, &#x60;withCandidateGroups&#x60;, &#x60; withoutCandidateGroups&#x60;.  See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.</value>
        [DataMember(Name = "orQueries", EmitDefaultValue = true)]
        public List<HistoricTaskInstanceQueryDto> OrQueries { get; set; }

        /// <summary>
        /// An array of criteria to sort the result by. Each element of the array is                     an object that specifies one ordering. The position in the array                     identifies the rank of an ordering, i.e., whether it is primary, secondary,                     etc. Sorting has no effect for &#x60;count&#x60; endpoints
        /// </summary>
        /// <value>An array of criteria to sort the result by. Each element of the array is                     an object that specifies one ordering. The position in the array                     identifies the rank of an ordering, i.e., whether it is primary, secondary,                     etc. Sorting has no effect for &#x60;count&#x60; endpoints</value>
        [DataMember(Name = "sorting", EmitDefaultValue = true)]
        public List<HistoricTaskInstanceQueryDtoSortingInner> Sorting { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class HistoricTaskInstanceQueryDto {\n");
            sb.Append("  TaskId: ").Append(TaskId).Append("\n");
            sb.Append("  TaskParentTaskId: ").Append(TaskParentTaskId).Append("\n");
            sb.Append("  ProcessInstanceId: ").Append(ProcessInstanceId).Append("\n");
            sb.Append("  ProcessInstanceBusinessKey: ").Append(ProcessInstanceBusinessKey).Append("\n");
            sb.Append("  ProcessInstanceBusinessKeyIn: ").Append(ProcessInstanceBusinessKeyIn).Append("\n");
            sb.Append("  ProcessInstanceBusinessKeyLike: ").Append(ProcessInstanceBusinessKeyLike).Append("\n");
            sb.Append("  ExecutionId: ").Append(ExecutionId).Append("\n");
            sb.Append("  ProcessDefinitionId: ").Append(ProcessDefinitionId).Append("\n");
            sb.Append("  ProcessDefinitionKey: ").Append(ProcessDefinitionKey).Append("\n");
            sb.Append("  ProcessDefinitionName: ").Append(ProcessDefinitionName).Append("\n");
            sb.Append("  CaseInstanceId: ").Append(CaseInstanceId).Append("\n");
            sb.Append("  CaseExecutionId: ").Append(CaseExecutionId).Append("\n");
            sb.Append("  CaseDefinitionId: ").Append(CaseDefinitionId).Append("\n");
            sb.Append("  CaseDefinitionKey: ").Append(CaseDefinitionKey).Append("\n");
            sb.Append("  CaseDefinitionName: ").Append(CaseDefinitionName).Append("\n");
            sb.Append("  ActivityInstanceIdIn: ").Append(ActivityInstanceIdIn).Append("\n");
            sb.Append("  TaskName: ").Append(TaskName).Append("\n");
            sb.Append("  TaskNameLike: ").Append(TaskNameLike).Append("\n");
            sb.Append("  TaskDescription: ").Append(TaskDescription).Append("\n");
            sb.Append("  TaskDescriptionLike: ").Append(TaskDescriptionLike).Append("\n");
            sb.Append("  TaskDefinitionKey: ").Append(TaskDefinitionKey).Append("\n");
            sb.Append("  TaskDefinitionKeyIn: ").Append(TaskDefinitionKeyIn).Append("\n");
            sb.Append("  TaskDeleteReason: ").Append(TaskDeleteReason).Append("\n");
            sb.Append("  TaskDeleteReasonLike: ").Append(TaskDeleteReasonLike).Append("\n");
            sb.Append("  TaskAssignee: ").Append(TaskAssignee).Append("\n");
            sb.Append("  TaskAssigneeLike: ").Append(TaskAssigneeLike).Append("\n");
            sb.Append("  TaskOwner: ").Append(TaskOwner).Append("\n");
            sb.Append("  TaskOwnerLike: ").Append(TaskOwnerLike).Append("\n");
            sb.Append("  TaskPriority: ").Append(TaskPriority).Append("\n");
            sb.Append("  Assigned: ").Append(Assigned).Append("\n");
            sb.Append("  Unassigned: ").Append(Unassigned).Append("\n");
            sb.Append("  Finished: ").Append(Finished).Append("\n");
            sb.Append("  Unfinished: ").Append(Unfinished).Append("\n");
            sb.Append("  ProcessFinished: ").Append(ProcessFinished).Append("\n");
            sb.Append("  ProcessUnfinished: ").Append(ProcessUnfinished).Append("\n");
            sb.Append("  TaskDueDate: ").Append(TaskDueDate).Append("\n");
            sb.Append("  TaskDueDateBefore: ").Append(TaskDueDateBefore).Append("\n");
            sb.Append("  TaskDueDateAfter: ").Append(TaskDueDateAfter).Append("\n");
            sb.Append("  WithoutTaskDueDate: ").Append(WithoutTaskDueDate).Append("\n");
            sb.Append("  TaskFollowUpDate: ").Append(TaskFollowUpDate).Append("\n");
            sb.Append("  TaskFollowUpDateBefore: ").Append(TaskFollowUpDateBefore).Append("\n");
            sb.Append("  TaskFollowUpDateAfter: ").Append(TaskFollowUpDateAfter).Append("\n");
            sb.Append("  StartedBefore: ").Append(StartedBefore).Append("\n");
            sb.Append("  StartedAfter: ").Append(StartedAfter).Append("\n");
            sb.Append("  FinishedBefore: ").Append(FinishedBefore).Append("\n");
            sb.Append("  FinishedAfter: ").Append(FinishedAfter).Append("\n");
            sb.Append("  TenantIdIn: ").Append(TenantIdIn).Append("\n");
            sb.Append("  WithoutTenantId: ").Append(WithoutTenantId).Append("\n");
            sb.Append("  TaskVariables: ").Append(TaskVariables).Append("\n");
            sb.Append("  ProcessVariables: ").Append(ProcessVariables).Append("\n");
            sb.Append("  VariableNamesIgnoreCase: ").Append(VariableNamesIgnoreCase).Append("\n");
            sb.Append("  VariableValuesIgnoreCase: ").Append(VariableValuesIgnoreCase).Append("\n");
            sb.Append("  TaskInvolvedUser: ").Append(TaskInvolvedUser).Append("\n");
            sb.Append("  TaskInvolvedGroup: ").Append(TaskInvolvedGroup).Append("\n");
            sb.Append("  TaskHadCandidateUser: ").Append(TaskHadCandidateUser).Append("\n");
            sb.Append("  TaskHadCandidateGroup: ").Append(TaskHadCandidateGroup).Append("\n");
            sb.Append("  WithCandidateGroups: ").Append(WithCandidateGroups).Append("\n");
            sb.Append("  WithoutCandidateGroups: ").Append(WithoutCandidateGroups).Append("\n");
            sb.Append("  OrQueries: ").Append(OrQueries).Append("\n");
            sb.Append("  Sorting: ").Append(Sorting).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
