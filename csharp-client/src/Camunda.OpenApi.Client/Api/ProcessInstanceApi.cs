/*
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * The version of the OpenAPI document: 7.15.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Camunda.OpenApi.Client.Client;
using Camunda.OpenApi.Client.Model;

namespace Camunda.OpenApi.Client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProcessInstanceApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Delete Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto DeleteAsyncHistoricQueryBased(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto));

        /// <summary>
        /// Delete Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> DeleteAsyncHistoricQueryBasedWithHttpInfo(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto));
        /// <summary>
        /// Delete
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns></returns>
        void DeleteProcessInstance(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?));

        /// <summary>
        /// Delete
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteProcessInstanceWithHttpInfo(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?));
        /// <summary>
        /// Delete Process Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns></returns>
        void DeleteProcessInstanceVariable(string id, string varName);

        /// <summary>
        /// Delete Process Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteProcessInstanceVariableWithHttpInfo(string id, string varName);
        /// <summary>
        /// Delete Async (POST)
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto DeleteProcessInstancesAsyncOperation(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto));

        /// <summary>
        /// Delete Async (POST)
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> DeleteProcessInstancesAsyncOperationWithHttpInfo(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto));
        /// <summary>
        /// Get Activity Instance
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ActivityInstanceDto</returns>
        ActivityInstanceDto GetActivityInstanceTree(string id);

        /// <summary>
        /// Get Activity Instance
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ApiResponse of ActivityInstanceDto</returns>
        ApiResponse<ActivityInstanceDto> GetActivityInstanceTreeWithHttpInfo(string id);
        /// <summary>
        /// Get Process Instance
        /// </summary>
        /// <remarks>
        /// Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <returns>ProcessInstanceDto</returns>
        ProcessInstanceDto GetProcessInstance(string id);

        /// <summary>
        /// Get Process Instance
        /// </summary>
        /// <remarks>
        /// Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <returns>ApiResponse of ProcessInstanceDto</returns>
        ApiResponse<ProcessInstanceDto> GetProcessInstanceWithHttpInfo(string id);
        /// <summary>
        /// Get Process Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>VariableValueDto</returns>
        VariableValueDto GetProcessInstanceVariable(string id, string varName, bool? deserializeValue = default(bool?));

        /// <summary>
        /// Get Process Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of VariableValueDto</returns>
        ApiResponse<VariableValueDto> GetProcessInstanceVariableWithHttpInfo(string id, string varName, bool? deserializeValue = default(bool?));
        /// <summary>
        /// Get Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>System.IO.Stream</returns>
        System.IO.Stream GetProcessInstanceVariableBinary(string id, string varName);

        /// <summary>
        /// Get Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        ApiResponse<System.IO.Stream> GetProcessInstanceVariableBinaryWithHttpInfo(string id, string varName);
        /// <summary>
        /// Get Process Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Dictionary&lt;string, VariableValueDto&gt;</returns>
        Dictionary<string, VariableValueDto> GetProcessInstanceVariables(string id, bool? deserializeValues = default(bool?));

        /// <summary>
        /// Get Process Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, VariableValueDto&gt;</returns>
        ApiResponse<Dictionary<string, VariableValueDto>> GetProcessInstanceVariablesWithHttpInfo(string id, bool? deserializeValues = default(bool?));
        /// <summary>
        /// Get List
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        List<ProcessInstanceDto> GetProcessInstances(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?));

        /// <summary>
        /// Get List
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        ApiResponse<List<ProcessInstanceDto>> GetProcessInstancesWithHttpInfo(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?));
        /// <summary>
        /// Get List Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>CountResultDto</returns>
        CountResultDto GetProcessInstancesCount(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?));

        /// <summary>
        /// Get List Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        ApiResponse<CountResultDto> GetProcessInstancesCountWithHttpInfo(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?));
        /// <summary>
        /// Modify Process Instance Execution State
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns></returns>
        void ModifyProcessInstance(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto));

        /// <summary>
        /// Modify Process Instance Execution State
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ModifyProcessInstanceWithHttpInfo(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto));
        /// <summary>
        /// Modify Process Instance Execution State Async
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto ModifyProcessInstanceAsyncOperation(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto));

        /// <summary>
        /// Modify Process Instance Execution State Async
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> ModifyProcessInstanceAsyncOperationWithHttpInfo(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto));
        /// <summary>
        /// Update/Delete Process Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns></returns>
        void ModifyProcessInstanceVariables(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto));

        /// <summary>
        /// Update/Delete Process Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ModifyProcessInstanceVariablesWithHttpInfo(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto));
        /// <summary>
        /// Get List (POST)
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        List<ProcessInstanceDto> QueryProcessInstances(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto));

        /// <summary>
        /// Get List (POST)
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        ApiResponse<List<ProcessInstanceDto>> QueryProcessInstancesWithHttpInfo(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto));
        /// <summary>
        /// Get List Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>CountResultDto</returns>
        CountResultDto QueryProcessInstancesCount(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto));

        /// <summary>
        /// Get List Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        ApiResponse<CountResultDto> QueryProcessInstancesCountWithHttpInfo(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto));
        /// <summary>
        /// Update Process Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns></returns>
        void SetProcessInstanceVariable(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto));

        /// <summary>
        /// Update Process Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetProcessInstanceVariableWithHttpInfo(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto));
        /// <summary>
        /// Update Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns></returns>
        void SetProcessInstanceVariableBinary(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string));

        /// <summary>
        /// Update Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetProcessInstanceVariableBinaryWithHttpInfo(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string));
        /// <summary>
        /// Set Job Retries Async (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto SetRetriesByProcess(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto));

        /// <summary>
        /// Set Job Retries Async (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> SetRetriesByProcessWithHttpInfo(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto));
        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto SetRetriesByProcessHistoricQueryBased(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto));

        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> SetRetriesByProcessHistoricQueryBasedWithHttpInfo(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto));
        /// <summary>
        /// Set Variables Async (POST)
        /// </summary>
        /// <remarks>
        /// Update or create runtime process variables in the root scope of process instances.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto SetVariablesAsyncOperation(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto));

        /// <summary>
        /// Set Variables Async (POST)
        /// </summary>
        /// <remarks>
        /// Update or create runtime process variables in the root scope of process instances.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> SetVariablesAsyncOperationWithHttpInfo(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto));
        /// <summary>
        /// Activate/Suspend In Group
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <returns></returns>
        void UpdateSuspensionState(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto));

        /// <summary>
        /// Activate/Suspend In Group
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSuspensionStateWithHttpInfo(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto));
        /// <summary>
        /// Activate/Suspend In Batch
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <returns>BatchDto</returns>
        BatchDto UpdateSuspensionStateAsyncOperation(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto));

        /// <summary>
        /// Activate/Suspend In Batch
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        ApiResponse<BatchDto> UpdateSuspensionStateAsyncOperationWithHttpInfo(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto));
        /// <summary>
        /// Activate/Suspend Process Instance By Id
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <returns></returns>
        void UpdateSuspensionStateById(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto));

        /// <summary>
        /// Activate/Suspend Process Instance By Id
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateSuspensionStateByIdWithHttpInfo(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProcessInstanceApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Delete Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> DeleteAsyncHistoricQueryBasedAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> DeleteAsyncHistoricQueryBasedWithHttpInfoAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteProcessInstanceAsync(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete
        /// </summary>
        /// <remarks>
        /// Deletes a running process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteProcessInstanceWithHttpInfoAsync(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete Process Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete Process Variable
        /// </summary>
        /// <remarks>
        /// Deletes a variable of a process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteProcessInstanceVariableWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete Async (POST)
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> DeleteProcessInstancesAsyncOperationAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete Async (POST)
        /// </summary>
        /// <remarks>
        /// Deletes multiple process instances asynchronously (batch).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> DeleteProcessInstancesAsyncOperationWithHttpInfoAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Activity Instance
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ActivityInstanceDto</returns>
        System.Threading.Tasks.Task<ActivityInstanceDto> GetActivityInstanceTreeAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Activity Instance
        /// </summary>
        /// <remarks>
        /// Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ActivityInstanceDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ActivityInstanceDto>> GetActivityInstanceTreeWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Process Instance
        /// </summary>
        /// <remarks>
        /// Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ProcessInstanceDto</returns>
        System.Threading.Tasks.Task<ProcessInstanceDto> GetProcessInstanceAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Process Instance
        /// </summary>
        /// <remarks>
        /// Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ProcessInstanceDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<ProcessInstanceDto>> GetProcessInstanceWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Process Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VariableValueDto</returns>
        System.Threading.Tasks.Task<VariableValueDto> GetProcessInstanceVariableAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Process Variable
        /// </summary>
        /// <remarks>
        /// Retrieves a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VariableValueDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<VariableValueDto>> GetProcessInstanceVariableWithHttpInfoAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        System.Threading.Tasks.Task<System.IO.Stream> GetProcessInstanceVariableBinaryAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        System.Threading.Tasks.Task<ApiResponse<System.IO.Stream>> GetProcessInstanceVariableBinaryWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Process Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dictionary&lt;string, VariableValueDto&gt;</returns>
        System.Threading.Tasks.Task<Dictionary<string, VariableValueDto>> GetProcessInstanceVariablesAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get Process Variables
        /// </summary>
        /// <remarks>
        /// Retrieves all variables of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, VariableValueDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<Dictionary<string, VariableValueDto>>> GetProcessInstanceVariablesWithHttpInfoAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get List
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        System.Threading.Tasks.Task<List<ProcessInstanceDto>> GetProcessInstancesAsync(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get List
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ProcessInstanceDto>>> GetProcessInstancesWithHttpInfoAsync(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get List Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        System.Threading.Tasks.Task<CountResultDto> GetProcessInstancesCountAsync(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get List Count
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill given parameters.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountResultDto>> GetProcessInstancesCountWithHttpInfoAsync(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Modify Process Instance Execution State
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ModifyProcessInstanceAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Modify Process Instance Execution State
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ModifyProcessInstanceWithHttpInfoAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Modify Process Instance Execution State Async
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> ModifyProcessInstanceAsyncOperationAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Modify Process Instance Execution State Async
        /// </summary>
        /// <remarks>
        /// Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> ModifyProcessInstanceAsyncOperationWithHttpInfoAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update/Delete Process Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ModifyProcessInstanceVariablesAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update/Delete Process Variables
        /// </summary>
        /// <remarks>
        /// Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ModifyProcessInstanceVariablesWithHttpInfoAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get List (POST)
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        System.Threading.Tasks.Task<List<ProcessInstanceDto>> QueryProcessInstancesAsync(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get List (POST)
        /// </summary>
        /// <remarks>
        /// Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ProcessInstanceDto>>> QueryProcessInstancesWithHttpInfoAsync(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get List Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        System.Threading.Tasks.Task<CountResultDto> QueryProcessInstancesCountAsync(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get List Count (POST)
        /// </summary>
        /// <remarks>
        /// Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<CountResultDto>> QueryProcessInstancesCountWithHttpInfoAsync(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update Process Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetProcessInstanceVariableAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update Process Variable
        /// </summary>
        /// <remarks>
        /// Sets a variable of a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetProcessInstanceVariableWithHttpInfoAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetProcessInstanceVariableBinaryAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Update Process Variable (Binary)
        /// </summary>
        /// <remarks>
        /// Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetProcessInstanceVariableBinaryWithHttpInfoAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Set Job Retries Async (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Set Job Retries Async (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> SetRetriesByProcessWithHttpInfoAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessHistoricQueryBasedAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST)
        /// </summary>
        /// <remarks>
        /// Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> SetRetriesByProcessHistoricQueryBasedWithHttpInfoAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Set Variables Async (POST)
        /// </summary>
        /// <remarks>
        /// Update or create runtime process variables in the root scope of process instances.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> SetVariablesAsyncOperationAsync(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Set Variables Async (POST)
        /// </summary>
        /// <remarks>
        /// Update or create runtime process variables in the root scope of process instances.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> SetVariablesAsyncOperationWithHttpInfoAsync(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Activate/Suspend In Group
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSuspensionStateAsync(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Activate/Suspend In Group
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSuspensionStateWithHttpInfoAsync(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Activate/Suspend In Batch
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        System.Threading.Tasks.Task<BatchDto> UpdateSuspensionStateAsyncOperationAsync(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Activate/Suspend In Batch
        /// </summary>
        /// <remarks>
        /// Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        System.Threading.Tasks.Task<ApiResponse<BatchDto>> UpdateSuspensionStateAsyncOperationWithHttpInfoAsync(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Activate/Suspend Process Instance By Id
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateSuspensionStateByIdAsync(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Activate/Suspend Process Instance By Id
        /// </summary>
        /// <remarks>
        /// Activates or suspends a given process instance by id.
        /// </remarks>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateSuspensionStateByIdWithHttpInfoAsync(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProcessInstanceApi : IProcessInstanceApiSync, IProcessInstanceApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ProcessInstanceApi : IProcessInstanceApi
    {
        private Camunda.OpenApi.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProcessInstanceApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProcessInstanceApi(String basePath)
        {
            this.Configuration = Camunda.OpenApi.Client.Client.Configuration.MergeConfigurations(
                Camunda.OpenApi.Client.Client.GlobalConfiguration.Instance,
                new Camunda.OpenApi.Client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Camunda.OpenApi.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Camunda.OpenApi.Client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Camunda.OpenApi.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ProcessInstanceApi(Camunda.OpenApi.Client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Camunda.OpenApi.Client.Client.Configuration.MergeConfigurations(
                Camunda.OpenApi.Client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Camunda.OpenApi.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Camunda.OpenApi.Client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Camunda.OpenApi.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProcessInstanceApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ProcessInstanceApi(Camunda.OpenApi.Client.Client.ISynchronousClient client, Camunda.OpenApi.Client.Client.IAsynchronousClient asyncClient, Camunda.OpenApi.Client.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Camunda.OpenApi.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Camunda.OpenApi.Client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Camunda.OpenApi.Client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Camunda.OpenApi.Client.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Camunda.OpenApi.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Delete Async Historic Query Based (POST) Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto DeleteAsyncHistoricQueryBased(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = DeleteAsyncHistoricQueryBasedWithHttpInfo(deleteProcessInstancesDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete Async Historic Query Based (POST) Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> DeleteAsyncHistoricQueryBasedWithHttpInfo(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = deleteProcessInstancesDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchDto>("/process-instance/delete-historic-query-based", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAsyncHistoricQueryBased", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Async Historic Query Based (POST) Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> DeleteAsyncHistoricQueryBasedAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = await DeleteAsyncHistoricQueryBasedWithHttpInfoAsync(deleteProcessInstancesDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete Async Historic Query Based (POST) Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<BatchDto>> DeleteAsyncHistoricQueryBasedWithHttpInfoAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = deleteProcessInstancesDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchDto>("/process-instance/delete-historic-query-based", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteAsyncHistoricQueryBased", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns></returns>
        public void DeleteProcessInstance(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?))
        {
            DeleteProcessInstanceWithHttpInfo(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists);
        }

        /// <summary>
        /// Delete Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> DeleteProcessInstanceWithHttpInfo(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstance");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (skipCustomListeners != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "skipCustomListeners", skipCustomListeners));
            }
            if (skipIoMappings != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "skipIoMappings", skipIoMappings));
            }
            if (skipSubprocesses != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "skipSubprocesses", skipSubprocesses));
            }
            if (failIfNotExists != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "failIfNotExists", failIfNotExists));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/process-instance/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProcessInstance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteProcessInstanceAsync(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteProcessInstanceWithHttpInfoAsync(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete Deletes a running process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be deleted.</param>
        /// <param name="skipCustomListeners">If set to true, the custom listeners will be skipped. (optional, default to false)</param>
        /// <param name="skipIoMappings">If set to true, the input/output mappings will be skipped. (optional, default to false)</param>
        /// <param name="skipSubprocesses">If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)</param>
        /// <param name="failIfNotExists">If set to false, the request will still be successful if the process id is not found. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> DeleteProcessInstanceWithHttpInfoAsync(string id, bool? skipCustomListeners = default(bool?), bool? skipIoMappings = default(bool?), bool? skipSubprocesses = default(bool?), bool? failIfNotExists = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstance");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (skipCustomListeners != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "skipCustomListeners", skipCustomListeners));
            }
            if (skipIoMappings != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "skipIoMappings", skipIoMappings));
            }
            if (skipSubprocesses != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "skipSubprocesses", skipSubprocesses));
            }
            if (failIfNotExists != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "failIfNotExists", failIfNotExists));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/process-instance/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProcessInstance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Process Variable Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns></returns>
        public void DeleteProcessInstanceVariable(string id, string varName)
        {
            DeleteProcessInstanceVariableWithHttpInfo(id, varName);
        }

        /// <summary>
        /// Delete Process Variable Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> DeleteProcessInstanceVariableWithHttpInfo(string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/process-instance/{id}/variables/{varName}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProcessInstanceVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Process Variable Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteProcessInstanceVariableAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteProcessInstanceVariableWithHttpInfoAsync(id, varName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete Process Variable Deletes a variable of a process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to delete the variable from.</param>
        /// <param name="varName">The name of the variable to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> DeleteProcessInstanceVariableWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->DeleteProcessInstanceVariable");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/process-instance/{id}/variables/{varName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProcessInstanceVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Async (POST) Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto DeleteProcessInstancesAsyncOperation(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = DeleteProcessInstancesAsyncOperationWithHttpInfo(deleteProcessInstancesDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete Async (POST) Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> DeleteProcessInstancesAsyncOperationWithHttpInfo(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = deleteProcessInstancesDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchDto>("/process-instance/delete", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProcessInstancesAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete Async (POST) Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> DeleteProcessInstancesAsyncOperationAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = await DeleteProcessInstancesAsyncOperationWithHttpInfoAsync(deleteProcessInstancesDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Delete Async (POST) Deletes multiple process instances asynchronously (batch).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deleteProcessInstancesDto">**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<BatchDto>> DeleteProcessInstancesAsyncOperationWithHttpInfoAsync(DeleteProcessInstancesDto deleteProcessInstancesDto = default(DeleteProcessInstancesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = deleteProcessInstancesDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchDto>("/process-instance/delete", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteProcessInstancesAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Activity Instance Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ActivityInstanceDto</returns>
        public ActivityInstanceDto GetActivityInstanceTree(string id)
        {
            Camunda.OpenApi.Client.Client.ApiResponse<ActivityInstanceDto> localVarResponse = GetActivityInstanceTreeWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Activity Instance Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <returns>ApiResponse of ActivityInstanceDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<ActivityInstanceDto> GetActivityInstanceTreeWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetActivityInstanceTree");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<ActivityInstanceDto>("/process-instance/{id}/activity-instances", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetActivityInstanceTree", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Activity Instance Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ActivityInstanceDto</returns>
        public async System.Threading.Tasks.Task<ActivityInstanceDto> GetActivityInstanceTreeAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<ActivityInstanceDto> localVarResponse = await GetActivityInstanceTreeWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Activity Instance Retrieves an Activity Instance (Tree) for a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance for which the activity instance should be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ActivityInstanceDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<ActivityInstanceDto>> GetActivityInstanceTreeWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetActivityInstanceTree");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ActivityInstanceDto>("/process-instance/{id}/activity-instances", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetActivityInstanceTree", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Instance Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <returns>ProcessInstanceDto</returns>
        public ProcessInstanceDto GetProcessInstance(string id)
        {
            Camunda.OpenApi.Client.Client.ApiResponse<ProcessInstanceDto> localVarResponse = GetProcessInstanceWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Instance Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <returns>ApiResponse of ProcessInstanceDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<ProcessInstanceDto> GetProcessInstanceWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstance");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<ProcessInstanceDto>("/process-instance/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Instance Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ProcessInstanceDto</returns>
        public async System.Threading.Tasks.Task<ProcessInstanceDto> GetProcessInstanceAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<ProcessInstanceDto> localVarResponse = await GetProcessInstanceWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Instance Retrieves a process instance by id, according to the &#x60;ProcessInstance&#x60; interface in the engine.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to be retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ProcessInstanceDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<ProcessInstanceDto>> GetProcessInstanceWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstance");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ProcessInstanceDto>("/process-instance/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Variable Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>VariableValueDto</returns>
        public VariableValueDto GetProcessInstanceVariable(string id, string varName, bool? deserializeValue = default(bool?))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<VariableValueDto> localVarResponse = GetProcessInstanceVariableWithHttpInfo(id, varName, deserializeValue);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Variable Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of VariableValueDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<VariableValueDto> GetProcessInstanceVariableWithHttpInfo(string id, string varName, bool? deserializeValue = default(bool?))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariable");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (deserializeValue != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deserializeValue", deserializeValue));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<VariableValueDto>("/process-instance/{id}/variables/{varName}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstanceVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Variable Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VariableValueDto</returns>
        public async System.Threading.Tasks.Task<VariableValueDto> GetProcessInstanceVariableAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<VariableValueDto> localVarResponse = await GetProcessInstanceVariableWithHttpInfoAsync(id, varName, deserializeValue, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Variable Retrieves a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="deserializeValue">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VariableValueDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<VariableValueDto>> GetProcessInstanceVariableWithHttpInfoAsync(string id, string varName, bool? deserializeValue = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariable");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (deserializeValue != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deserializeValue", deserializeValue));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<VariableValueDto>("/process-instance/{id}/variables/{varName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstanceVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Variable (Binary) Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>System.IO.Stream</returns>
        public System.IO.Stream GetProcessInstanceVariableBinary(string id, string varName)
        {
            Camunda.OpenApi.Client.Client.ApiResponse<System.IO.Stream> localVarResponse = GetProcessInstanceVariableBinaryWithHttpInfo(id, varName);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Variable (Binary) Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<System.IO.Stream> GetProcessInstanceVariableBinaryWithHttpInfo(string id, string varName)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/octet-stream",
                "text/plain",
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<System.IO.Stream>("/process-instance/{id}/variables/{varName}/data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstanceVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Variable (Binary) Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        public async System.Threading.Tasks.Task<System.IO.Stream> GetProcessInstanceVariableBinaryAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<System.IO.Stream> localVarResponse = await GetProcessInstanceVariableBinaryWithHttpInfoAsync(id, varName, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Variable (Binary) Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<System.IO.Stream>> GetProcessInstanceVariableBinaryWithHttpInfoAsync(string id, string varName, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->GetProcessInstanceVariableBinary");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/octet-stream",
                "text/plain",
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<System.IO.Stream>("/process-instance/{id}/variables/{varName}/data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstanceVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Variables Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>Dictionary&lt;string, VariableValueDto&gt;</returns>
        public Dictionary<string, VariableValueDto> GetProcessInstanceVariables(string id, bool? deserializeValues = default(bool?))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<Dictionary<string, VariableValueDto>> localVarResponse = GetProcessInstanceVariablesWithHttpInfo(id, deserializeValues);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Variables Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, VariableValueDto&gt;</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Dictionary<string, VariableValueDto>> GetProcessInstanceVariablesWithHttpInfo(string id, bool? deserializeValues = default(bool?))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariables");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (deserializeValues != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deserializeValues", deserializeValues));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<Dictionary<string, VariableValueDto>>("/process-instance/{id}/variables", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstanceVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Process Variables Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Dictionary&lt;string, VariableValueDto&gt;</returns>
        public async System.Threading.Tasks.Task<Dictionary<string, VariableValueDto>> GetProcessInstanceVariablesAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<Dictionary<string, VariableValueDto>> localVarResponse = await GetProcessInstanceVariablesWithHttpInfoAsync(id, deserializeValues, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Process Variables Retrieves all variables of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variables from.</param>
        /// <param name="deserializeValues">Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, VariableValueDto&gt;)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Dictionary<string, VariableValueDto>>> GetProcessInstanceVariablesWithHttpInfoAsync(string id, bool? deserializeValues = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->GetProcessInstanceVariables");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            if (deserializeValues != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deserializeValues", deserializeValues));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Dictionary<string, VariableValueDto>>("/process-instance/{id}/variables", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstanceVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        public List<ProcessInstanceDto> GetProcessInstances(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>> localVarResponse = GetProcessInstancesWithHttpInfo(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>> GetProcessInstancesWithHttpInfo(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "sortBy", sortBy));
            }
            if (sortOrder != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "sortOrder", sortOrder));
            }
            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }
            if (processInstanceIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processInstanceIds", processInstanceIds));
            }
            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (businessKeyLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKeyLike", businessKeyLike));
            }
            if (caseInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "caseInstanceId", caseInstanceId));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processDefinitionKeyIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyIn", processDefinitionKeyIn));
            }
            if (processDefinitionKeyNotIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn));
            }
            if (deploymentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deploymentId", deploymentId));
            }
            if (superProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superProcessInstance", superProcessInstance));
            }
            if (subProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subProcessInstance", subProcessInstance));
            }
            if (superCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superCaseInstance", superCaseInstance));
            }
            if (subCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subCaseInstance", subCaseInstance));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (withIncident != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withIncident", withIncident));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (withoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withoutTenantId", withoutTenantId));
            }
            if (processDefinitionWithoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId));
            }
            if (activityIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "activityIdIn", activityIdIn));
            }
            if (rootProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "rootProcessInstances", rootProcessInstances));
            }
            if (leafProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "leafProcessInstances", leafProcessInstances));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ProcessInstanceDto>>("/process-instance", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        public async System.Threading.Tasks.Task<List<ProcessInstanceDto>> GetProcessInstancesAsync(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>> localVarResponse = await GetProcessInstancesWithHttpInfoAsync(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)</param>
        /// <param name="sortOrder">Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)</param>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>>> GetProcessInstancesWithHttpInfoAsync(string sortBy = default(string), string sortOrder = default(string), int? firstResult = default(int?), int? maxResults = default(int?), string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (sortBy != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "sortBy", sortBy));
            }
            if (sortOrder != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "sortOrder", sortOrder));
            }
            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }
            if (processInstanceIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processInstanceIds", processInstanceIds));
            }
            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (businessKeyLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKeyLike", businessKeyLike));
            }
            if (caseInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "caseInstanceId", caseInstanceId));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processDefinitionKeyIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyIn", processDefinitionKeyIn));
            }
            if (processDefinitionKeyNotIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn));
            }
            if (deploymentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deploymentId", deploymentId));
            }
            if (superProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superProcessInstance", superProcessInstance));
            }
            if (subProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subProcessInstance", subProcessInstance));
            }
            if (superCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superCaseInstance", superCaseInstance));
            }
            if (subCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subCaseInstance", subCaseInstance));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (withIncident != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withIncident", withIncident));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (withoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withoutTenantId", withoutTenantId));
            }
            if (processDefinitionWithoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId));
            }
            if (activityIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "activityIdIn", activityIdIn));
            }
            if (rootProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "rootProcessInstances", rootProcessInstances));
            }
            if (leafProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "leafProcessInstances", leafProcessInstances));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ProcessInstanceDto>>("/process-instance", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List Count Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>CountResultDto</returns>
        public CountResultDto GetProcessInstancesCount(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto> localVarResponse = GetProcessInstancesCountWithHttpInfo(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List Count Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto> GetProcessInstancesCountWithHttpInfo(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (processInstanceIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processInstanceIds", processInstanceIds));
            }
            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (businessKeyLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKeyLike", businessKeyLike));
            }
            if (caseInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "caseInstanceId", caseInstanceId));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processDefinitionKeyIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyIn", processDefinitionKeyIn));
            }
            if (processDefinitionKeyNotIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn));
            }
            if (deploymentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deploymentId", deploymentId));
            }
            if (superProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superProcessInstance", superProcessInstance));
            }
            if (subProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subProcessInstance", subProcessInstance));
            }
            if (superCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superCaseInstance", superCaseInstance));
            }
            if (subCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subCaseInstance", subCaseInstance));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (withIncident != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withIncident", withIncident));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (withoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withoutTenantId", withoutTenantId));
            }
            if (processDefinitionWithoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId));
            }
            if (activityIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "activityIdIn", activityIdIn));
            }
            if (rootProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "rootProcessInstances", rootProcessInstances));
            }
            if (leafProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "leafProcessInstances", leafProcessInstances));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<CountResultDto>("/process-instance/count", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstancesCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List Count Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        public async System.Threading.Tasks.Task<CountResultDto> GetProcessInstancesCountAsync(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto> localVarResponse = await GetProcessInstancesCountWithHttpInfoAsync(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List Count Queries for the number of process instances that fulfill given parameters.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceIds">Filter by a comma-separated list of process instance ids. (optional)</param>
        /// <param name="businessKey">Filter by process instance business key. (optional)</param>
        /// <param name="businessKeyLike">Filter by process instance business key that the parameter is a substring of. (optional)</param>
        /// <param name="caseInstanceId">Filter by case instance id. (optional)</param>
        /// <param name="processDefinitionId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="processDefinitionKey">Filter by the key of the process definition the instances run on. (optional)</param>
        /// <param name="processDefinitionKeyIn">Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)</param>
        /// <param name="processDefinitionKeyNotIn">Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)</param>
        /// <param name="deploymentId">Filter by the deployment the id belongs to. (optional)</param>
        /// <param name="superProcessInstance">Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)</param>
        /// <param name="subProcessInstance">Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)</param>
        /// <param name="superCaseInstance">Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)</param>
        /// <param name="subCaseInstance">Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)</param>
        /// <param name="active">Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="suspended">Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)</param>
        /// <param name="withIncident">Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)</param>
        /// <param name="incidentId">Filter by the incident id. (optional)</param>
        /// <param name="incidentType">Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)</param>
        /// <param name="incidentMessage">Filter by the incident message. Exact match. (optional)</param>
        /// <param name="incidentMessageLike">Filter by the incident message that the parameter is a substring of. (optional)</param>
        /// <param name="tenantIdIn">Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)</param>
        /// <param name="withoutTenantId">Only include process instances which belong to no tenant. (optional, default to false)</param>
        /// <param name="processDefinitionWithoutTenantId">Only include process instances which process definition has no tenant id. (optional, default to false)</param>
        /// <param name="activityIdIn">Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)</param>
        /// <param name="rootProcessInstances">Restrict the query to all process instances that are top level process instances. (optional, default to false)</param>
        /// <param name="leafProcessInstances">Restrict the query to all process instances that are leaf instances. (i.e. don&#39;t have any sub instances). (optional, default to false)</param>
        /// <param name="variables">Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)</param>
        /// <param name="variableNamesIgnoreCase">Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)</param>
        /// <param name="variableValuesIgnoreCase">Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto>> GetProcessInstancesCountWithHttpInfoAsync(string processInstanceIds = default(string), string businessKey = default(string), string businessKeyLike = default(string), string caseInstanceId = default(string), string processDefinitionId = default(string), string processDefinitionKey = default(string), string processDefinitionKeyIn = default(string), string processDefinitionKeyNotIn = default(string), string deploymentId = default(string), string superProcessInstance = default(string), string subProcessInstance = default(string), string superCaseInstance = default(string), string subCaseInstance = default(string), bool? active = default(bool?), bool? suspended = default(bool?), bool? withIncident = default(bool?), string incidentId = default(string), string incidentType = default(string), string incidentMessage = default(string), string incidentMessageLike = default(string), string tenantIdIn = default(string), bool? withoutTenantId = default(bool?), bool? processDefinitionWithoutTenantId = default(bool?), string activityIdIn = default(string), bool? rootProcessInstances = default(bool?), bool? leafProcessInstances = default(bool?), string variables = default(string), bool? variableNamesIgnoreCase = default(bool?), bool? variableValuesIgnoreCase = default(bool?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (processInstanceIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processInstanceIds", processInstanceIds));
            }
            if (businessKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKey", businessKey));
            }
            if (businessKeyLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "businessKeyLike", businessKeyLike));
            }
            if (caseInstanceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "caseInstanceId", caseInstanceId));
            }
            if (processDefinitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionId", processDefinitionId));
            }
            if (processDefinitionKey != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKey", processDefinitionKey));
            }
            if (processDefinitionKeyIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyIn", processDefinitionKeyIn));
            }
            if (processDefinitionKeyNotIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionKeyNotIn", processDefinitionKeyNotIn));
            }
            if (deploymentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "deploymentId", deploymentId));
            }
            if (superProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superProcessInstance", superProcessInstance));
            }
            if (subProcessInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subProcessInstance", subProcessInstance));
            }
            if (superCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "superCaseInstance", superCaseInstance));
            }
            if (subCaseInstance != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "subCaseInstance", subCaseInstance));
            }
            if (active != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "active", active));
            }
            if (suspended != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "suspended", suspended));
            }
            if (withIncident != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withIncident", withIncident));
            }
            if (incidentId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentId", incidentId));
            }
            if (incidentType != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentType", incidentType));
            }
            if (incidentMessage != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessage", incidentMessage));
            }
            if (incidentMessageLike != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "incidentMessageLike", incidentMessageLike));
            }
            if (tenantIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "tenantIdIn", tenantIdIn));
            }
            if (withoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "withoutTenantId", withoutTenantId));
            }
            if (processDefinitionWithoutTenantId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "processDefinitionWithoutTenantId", processDefinitionWithoutTenantId));
            }
            if (activityIdIn != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "activityIdIn", activityIdIn));
            }
            if (rootProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "rootProcessInstances", rootProcessInstances));
            }
            if (leafProcessInstances != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "leafProcessInstances", leafProcessInstances));
            }
            if (variables != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variables", variables));
            }
            if (variableNamesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableNamesIgnoreCase", variableNamesIgnoreCase));
            }
            if (variableValuesIgnoreCase != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "variableValuesIgnoreCase", variableValuesIgnoreCase));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<CountResultDto>("/process-instance/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetProcessInstancesCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Modify Process Instance Execution State Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns></returns>
        public void ModifyProcessInstance(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto))
        {
            ModifyProcessInstanceWithHttpInfo(id, processInstanceModificationDto);
        }

        /// <summary>
        /// Modify Process Instance Execution State Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> ModifyProcessInstanceWithHttpInfo(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstance");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = processInstanceModificationDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/process-instance/{id}/modification", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyProcessInstance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Modify Process Instance Execution State Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ModifyProcessInstanceAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ModifyProcessInstanceWithHttpInfoAsync(id, processInstanceModificationDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Modify Process Instance Execution State Submits a list of modification instructions to change a process instance&#39;s execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> ModifyProcessInstanceWithHttpInfoAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstance");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = processInstanceModificationDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/process-instance/{id}/modification", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyProcessInstance", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Modify Process Instance Execution State Async Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto ModifyProcessInstanceAsyncOperation(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = ModifyProcessInstanceAsyncOperationWithHttpInfo(id, processInstanceModificationDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Modify Process Instance Execution State Async Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> ModifyProcessInstanceAsyncOperationWithHttpInfo(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceAsyncOperation");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = processInstanceModificationDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchDto>("/process-instance/{id}/modification-async", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyProcessInstanceAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Modify Process Instance Execution State Async Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> ModifyProcessInstanceAsyncOperationAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = await ModifyProcessInstanceAsyncOperationWithHttpInfoAsync(id, processInstanceModificationDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Modify Process Instance Execution State Async Submits a list of modification instructions to change a process instance&#39;s execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request&#39;s body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.15/user-guide/process-engine/process-instance-modification/).
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to modify.</param>
        /// <param name="processInstanceModificationDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<BatchDto>> ModifyProcessInstanceAsyncOperationWithHttpInfoAsync(string id, ProcessInstanceModificationDto processInstanceModificationDto = default(ProcessInstanceModificationDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceAsyncOperation");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = processInstanceModificationDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchDto>("/process-instance/{id}/modification-async", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyProcessInstanceAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update/Delete Process Variables Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns></returns>
        public void ModifyProcessInstanceVariables(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto))
        {
            ModifyProcessInstanceVariablesWithHttpInfo(id, patchVariablesDto);
        }

        /// <summary>
        /// Update/Delete Process Variables Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> ModifyProcessInstanceVariablesWithHttpInfo(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceVariables");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = patchVariablesDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/process-instance/{id}/variables", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyProcessInstanceVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update/Delete Process Variables Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ModifyProcessInstanceVariablesAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await ModifyProcessInstanceVariablesWithHttpInfoAsync(id, patchVariablesDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Update/Delete Process Variables Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set variables for.</param>
        /// <param name="patchVariablesDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> ModifyProcessInstanceVariablesWithHttpInfoAsync(string id, PatchVariablesDto patchVariablesDto = default(PatchVariablesDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->ModifyProcessInstanceVariables");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = patchVariablesDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/process-instance/{id}/variables", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ModifyProcessInstanceVariables", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List (POST) Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>List&lt;ProcessInstanceDto&gt;</returns>
        public List<ProcessInstanceDto> QueryProcessInstances(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>> localVarResponse = QueryProcessInstancesWithHttpInfo(firstResult, maxResults, processInstanceQueryDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List (POST) Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>ApiResponse of List&lt;ProcessInstanceDto&gt;</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>> QueryProcessInstancesWithHttpInfo(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }
            localVarRequestOptions.Data = processInstanceQueryDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<List<ProcessInstanceDto>>("/process-instance", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryProcessInstances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List (POST) Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;ProcessInstanceDto&gt;</returns>
        public async System.Threading.Tasks.Task<List<ProcessInstanceDto>> QueryProcessInstancesAsync(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>> localVarResponse = await QueryProcessInstancesWithHttpInfoAsync(firstResult, maxResults, processInstanceQueryDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List (POST) Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types &#x60;string&#x60;, &#x60;number&#x60; or &#x60;boolean&#x60;.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="firstResult">Pagination of results. Specifies the index of the first result to return. (optional)</param>
        /// <param name="maxResults">Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)</param>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;ProcessInstanceDto&gt;)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<List<ProcessInstanceDto>>> QueryProcessInstancesWithHttpInfoAsync(int? firstResult = default(int?), int? maxResults = default(int?), ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (firstResult != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "firstResult", firstResult));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Camunda.OpenApi.Client.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }
            localVarRequestOptions.Data = processInstanceQueryDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<ProcessInstanceDto>>("/process-instance", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryProcessInstances", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List Count (POST) Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>CountResultDto</returns>
        public CountResultDto QueryProcessInstancesCount(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto> localVarResponse = QueryProcessInstancesCountWithHttpInfo(processInstanceQueryDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List Count (POST) Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <returns>ApiResponse of CountResultDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto> QueryProcessInstancesCountWithHttpInfo(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = processInstanceQueryDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<CountResultDto>("/process-instance/count", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryProcessInstancesCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get List Count (POST) Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CountResultDto</returns>
        public async System.Threading.Tasks.Task<CountResultDto> QueryProcessInstancesCountAsync(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto> localVarResponse = await QueryProcessInstancesCountWithHttpInfoAsync(processInstanceQueryDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get List Count (POST) Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceQueryDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CountResultDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<CountResultDto>> QueryProcessInstancesCountWithHttpInfoAsync(ProcessInstanceQueryDto processInstanceQueryDto = default(ProcessInstanceQueryDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = processInstanceQueryDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<CountResultDto>("/process-instance/count", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("QueryProcessInstancesCount", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Process Variable Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns></returns>
        public void SetProcessInstanceVariable(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto))
        {
            SetProcessInstanceVariableWithHttpInfo(id, varName, variableValueDto);
        }

        /// <summary>
        /// Update Process Variable Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> SetProcessInstanceVariableWithHttpInfo(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariable");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter
            localVarRequestOptions.Data = variableValueDto;


            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/process-instance/{id}/variables/{varName}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetProcessInstanceVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Process Variable Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetProcessInstanceVariableAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SetProcessInstanceVariableWithHttpInfoAsync(id, varName, variableValueDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Update Process Variable Sets a variable of a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to set the variable for.</param>
        /// <param name="varName">The name of the variable to set.</param>
        /// <param name="variableValueDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> SetProcessInstanceVariableWithHttpInfoAsync(string id, string varName, VariableValueDto variableValueDto = default(VariableValueDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariable");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariable");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter
            localVarRequestOptions.Data = variableValueDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/process-instance/{id}/variables/{varName}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetProcessInstanceVariable", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Process Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns></returns>
        public void SetProcessInstanceVariableBinary(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string))
        {
            SetProcessInstanceVariableBinaryWithHttpInfo(id, varName, data, valueType);
        }

        /// <summary>
        /// Update Process Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> SetProcessInstanceVariableBinaryWithHttpInfo(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }
            if (valueType != null)
            {
                localVarRequestOptions.FormParameters.Add("valueType", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(valueType)); // form parameter
            }


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/process-instance/{id}/variables/{varName}/data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetProcessInstanceVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Process Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetProcessInstanceVariableBinaryAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await SetProcessInstanceVariableBinaryWithHttpInfoAsync(id, varName, data, valueType, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Update Process Variable (Binary) Sets the serialized value for a binary variable or the binary value for a file variable.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to retrieve the variable for.</param>
        /// <param name="varName">The name of the variable to retrieve.</param>
        /// <param name="data">The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory. (optional)</param>
        /// <param name="valueType">The name of the variable type. Either Bytes for a byte array variable or File for a file variable. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> SetProcessInstanceVariableBinaryWithHttpInfoAsync(string id, string varName, System.IO.Stream data = default(System.IO.Stream), string valueType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");

            // verify the required parameter 'varName' is set
            if (varName == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'varName' when calling ProcessInstanceApi->SetProcessInstanceVariableBinary");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.PathParameters.Add("varName", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(varName)); // path parameter
            if (data != null)
            {
                localVarRequestOptions.FileParameters.Add("data", data);
            }
            if (valueType != null)
            {
                localVarRequestOptions.FormParameters.Add("valueType", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(valueType)); // form parameter
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/process-instance/{id}/variables/{varName}/data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetProcessInstanceVariableBinary", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set Job Retries Async (POST) Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto SetRetriesByProcess(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = SetRetriesByProcessWithHttpInfo(setJobRetriesByProcessDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set Job Retries Async (POST) Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> SetRetriesByProcessWithHttpInfo(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = setJobRetriesByProcessDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchDto>("/process-instance/job-retries", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetRetriesByProcess", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set Job Retries Async (POST) Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = await SetRetriesByProcessWithHttpInfoAsync(setJobRetriesByProcessDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set Job Retries Async (POST) Create a batch to set retries of jobs associated with given processes asynchronously.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and processInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<BatchDto>> SetRetriesByProcessWithHttpInfoAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = setJobRetriesByProcessDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchDto>("/process-instance/job-retries", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetRetriesByProcess", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST) Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto SetRetriesByProcessHistoricQueryBased(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = SetRetriesByProcessHistoricQueryBasedWithHttpInfo(setJobRetriesByProcessDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST) Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> SetRetriesByProcessHistoricQueryBasedWithHttpInfo(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = setJobRetriesByProcessDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchDto>("/process-instance/job-retries-historic-query-based", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetRetriesByProcessHistoricQueryBased", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST) Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> SetRetriesByProcessHistoricQueryBasedAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = await SetRetriesByProcessHistoricQueryBasedWithHttpInfoAsync(setJobRetriesByProcessDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set Job Retries Async Historic Query Based (POST) Create a batch to set retries of jobs asynchronously based on a historic process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setJobRetriesByProcessDto">Please note that if both processInstances and historicProcessInstanceQuery are provided, then the resulting execution will be performed on the union of these sets. **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<BatchDto>> SetRetriesByProcessHistoricQueryBasedWithHttpInfoAsync(SetJobRetriesByProcessDto setJobRetriesByProcessDto = default(SetJobRetriesByProcessDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = setJobRetriesByProcessDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchDto>("/process-instance/job-retries-historic-query-based", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetRetriesByProcessHistoricQueryBased", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set Variables Async (POST) Update or create runtime process variables in the root scope of process instances.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto SetVariablesAsyncOperation(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = SetVariablesAsyncOperationWithHttpInfo(setVariablesAsyncDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set Variables Async (POST) Update or create runtime process variables in the root scope of process instances.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> SetVariablesAsyncOperationWithHttpInfo(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = setVariablesAsyncDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchDto>("/process-instance/variables-async", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetVariablesAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set Variables Async (POST) Update or create runtime process variables in the root scope of process instances.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> SetVariablesAsyncOperationAsync(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = await SetVariablesAsyncOperationWithHttpInfoAsync(setVariablesAsyncDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set Variables Async (POST) Update or create runtime process variables in the root scope of process instances.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="setVariablesAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<BatchDto>> SetVariablesAsyncOperationWithHttpInfoAsync(SetVariablesAsyncDto setVariablesAsyncDto = default(SetVariablesAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = setVariablesAsyncDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchDto>("/process-instance/variables-async", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetVariablesAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Activate/Suspend In Group Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <returns></returns>
        public void UpdateSuspensionState(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto))
        {
            UpdateSuspensionStateWithHttpInfo(processInstanceSuspensionStateDto);
        }

        /// <summary>
        /// Activate/Suspend In Group Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> UpdateSuspensionStateWithHttpInfo(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = processInstanceSuspensionStateDto;


            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/process-instance/suspended", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSuspensionState", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Activate/Suspend In Group Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSuspensionStateAsync(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await UpdateSuspensionStateWithHttpInfoAsync(processInstanceSuspensionStateDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Activate/Suspend In Group Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * &#x60;suspend&#x60; * &#x60;processDefinitionId&#x60;  # Activate/Suspend Process Instance By Process Definition Key  * &#x60;suspend&#x60; * &#x60;processDefinitionKey&#x60; * &#x60;processDefinitionTenantId&#x60; * &#x60;processDefinitionWithoutTenantId&#x60;  # Activate/Suspend Process Instance In Group * &#x60;suspend&#x60; * &#x60;processInstanceIds&#x60; * &#x60;processInstanceQuery&#x60; * &#x60;historicProcessInstanceQuery&#x60;
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> UpdateSuspensionStateWithHttpInfoAsync(ProcessInstanceSuspensionStateDto processInstanceSuspensionStateDto = default(ProcessInstanceSuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = processInstanceSuspensionStateDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/process-instance/suspended", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSuspensionState", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Activate/Suspend In Batch Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <returns>BatchDto</returns>
        public BatchDto UpdateSuspensionStateAsyncOperation(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = UpdateSuspensionStateAsyncOperationWithHttpInfo(processInstanceSuspensionStateAsyncDto);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Activate/Suspend In Batch Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <returns>ApiResponse of BatchDto</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> UpdateSuspensionStateAsyncOperationWithHttpInfo(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto))
        {
            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = processInstanceSuspensionStateAsyncDto;


            // make the HTTP request
            var localVarResponse = this.Client.Post<BatchDto>("/process-instance/suspended-async", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSuspensionStateAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Activate/Suspend In Batch Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BatchDto</returns>
        public async System.Threading.Tasks.Task<BatchDto> UpdateSuspensionStateAsyncOperationAsync(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Camunda.OpenApi.Client.Client.ApiResponse<BatchDto> localVarResponse = await UpdateSuspensionStateAsyncOperationWithHttpInfoAsync(processInstanceSuspensionStateAsyncDto, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Activate/Suspend In Batch Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="processInstanceSuspensionStateAsyncDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BatchDto)</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<BatchDto>> UpdateSuspensionStateAsyncOperationWithHttpInfoAsync(ProcessInstanceSuspensionStateAsyncDto processInstanceSuspensionStateAsyncDto = default(ProcessInstanceSuspensionStateAsyncDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = processInstanceSuspensionStateAsyncDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<BatchDto>("/process-instance/suspended-async", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSuspensionStateAsyncOperation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Activate/Suspend Process Instance By Id Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <returns></returns>
        public void UpdateSuspensionStateById(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto))
        {
            UpdateSuspensionStateByIdWithHttpInfo(id, suspensionStateDto);
        }

        /// <summary>
        /// Activate/Suspend Process Instance By Id Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Camunda.OpenApi.Client.Client.ApiResponse<Object> UpdateSuspensionStateByIdWithHttpInfo(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->UpdateSuspensionStateById");

            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
            };

            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = suspensionStateDto;


            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/process-instance/{id}/suspended", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSuspensionStateById", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Activate/Suspend Process Instance By Id Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateSuspensionStateByIdAsync(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await UpdateSuspensionStateByIdWithHttpInfoAsync(id, suspensionStateDto, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Activate/Suspend Process Instance By Id Activates or suspends a given process instance by id.
        /// </summary>
        /// <exception cref="Camunda.OpenApi.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the process instance to activate or suspend.</param>
        /// <param name="suspensionStateDto"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Camunda.OpenApi.Client.Client.ApiResponse<Object>> UpdateSuspensionStateByIdWithHttpInfoAsync(string id, SuspensionStateDto suspensionStateDto = default(SuspensionStateDto), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Camunda.OpenApi.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ProcessInstanceApi->UpdateSuspensionStateById");


            Camunda.OpenApi.Client.Client.RequestOptions localVarRequestOptions = new Camunda.OpenApi.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
            };


            var localVarContentType = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Camunda.OpenApi.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Camunda.OpenApi.Client.Client.ClientUtils.ParameterToString(id)); // path parameter
            localVarRequestOptions.Data = suspensionStateDto;


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/process-instance/{id}/suspended", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateSuspensionStateById", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
